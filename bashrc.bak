#!/bin/bash
iatest=$(expr index "$-" i)
#Version: 01_2023
#A.Gnl CONFIG
#B.EnvVariables(Global)
#C.Alias
#D.Funcs

#A.Gnl Configs
#If not running interactively, do nothing
[[ $- != *i* ]] && return
#Source Global dfn
[[ -f /etc/bashrc ]] && . /etc/bashrc

# Enable bash programmable completion features in interactive shells
if [ -f /usr/share/bash-completion/bash_completion ]; then
	. /usr/share/bash-completion/bash_completion
elif [ -f /etc/bash_completion ]; then
	. /etc/bash_completion
fi


#PROMPT
PS1='[\A\d][\u@\h:\w]-> '
#Disable Bells
if [[ $iatest -gt 0 ]]; then bind "set bell-style visible"; fi
#Ignore case on auto-completion
if [[ $iatest -gt 0 ]]; then bind "set completion-ignore-case on"; fi
### Show auto-completion list automatically, without double tab
if [[ $iatest -gt 0 ]]; then bind "set show-all-if-ambiguous On"; fi
#set -o vi #set CLI vi-mode

# Check the window size after each command and, if necessary, update the values of LINES and COLUMNS
shopt -s checkwinsize

#umask 0002 #set umask to make Dir sharing easier

#B.EnvVars(Gloabl)
###FZF_ripgrep, -m multiple selections via TAB
if type rg &> /dev/null; then
  export FZF_DEFAULT_COMMAND='rg --files'
  export FZF_DEFAULT_OPTS='-m --height 35% --reverse --border'
fi
### $HISTORY
export HISTCONTROL=erasedups:ignoredups:ignorespace:ignoreboth
export HISTIGNORE="&:c:p:x:h:r:.:..:...:cd*:lc*:cl*:ls*:ll:la:ld:l.:lab:dt:ds:dn:db:df:ps:exit:clear:history*:*--help:man *"
export HISTFILESIZE=10000
export HISTSIZE=500
export HISTTIMEFORMAT="%y/%m/%d %T " 
### $PATH
export PATH="${PATH}:${HOME}/.scripts"
export PATH="${HOME}/.local/bin:${PATH}"
export LD_LIBRARY_PATH="${HOME}/.local/lib64:${HOME}/.local/lib32:${HOME}/.local/lib:/usr/local/lib64:/usr/local/lib32:/usr/local/lib:${LD_LIBRARY_PATH}"
### Default Apps
export EDITOR="vim"
export SUDO_EDITOR="${EDITOR}"
export VISUAL="${EDITOR}"
export TERM="alacritty"
export BROWSER="brave-browser-nightly"
### EyeCandycolors
export CLICOLOR=1
export LS_COLORS='no=00:fi=00:di=00;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:*.wav=01;35:*.xml=00;31:'
alias grep="/usr/bin/grep $GREP_OPTIONS --color=auto"
unset GREP_OPTIONS
alias diff="diff --color=auto"
alias ip="ip -color=auto"
alias dm="xrandr --output eDP-1 --brightness 0.3"
    ##Color manpages in less
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'
    ##GCC warnings&errors
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'
    ##Darkmode
export GTK_THEME=Adwaita:dark, GTK2_RC_FILES=/usr/share/themes/Adwaita-dark/gtk-2.0/gtkrc, QT_STYLE_OVERRIDE=Adwaita-dark

#C.ALIASi
#To make good aliases, list top 10 cmds run most.
#history | awk '{cmd[$2]++} END {for(elem in cmd) {print cmd[elem] " " elem}}' | sort -n -r | head -10
#if cmds aliased
alias ckcmd="type -t"
alias cp='cp -i'
alias mv='mv -i'
# Remove dir w/all files
alias rmd='/bin/rm -i  --recursive --force --verbose '
alias less='less -R'

alias pdg="sudo pacman -Sy archlinux-keyring ; sudo  pacman -Su ; sudo pacman -Sc ; sudo pacman -Qtdq | sudo pacman -Rns -"
alias ps="sudo pacman -Ss"
alias pi="sudo pacman -S"
# Install&Remove pkgs(pacman/AUR helper as preference)
function in() {
    yay -Slq | fzf -q "$1" -m --preview 'yay -Si {1}'| xargs -ro yay -S
}
function re() {
    yay -Qq | fzf -q "$1" -m --preview 'yay -Qi {1}' | xargs -ro yay -Rns
}

alias c='clear ; l'
alias h='history'
alias t='tree --dirsfirst -F'
alias l="ls -ahl --color=auto"
alias ldoc="cd ~/Documents; ls -ahl --color=auto"
alias ldl="cd ~/Downloads; ls -ahl --color=auto"
alias lh="cd ~/; ls -ahl --color=auto "
#Top10  largest files/dirs in current dir
alias lgf='ls -1Rhs | sed -e "s/^ *//" | grep "^[0-9]" | sort -hr | head -n40'
alias lga='du -ah . | sort -rh | head -40'
#Multidir listing
#alias lx='ls -lXBh' # sort by extension
#alias lk='ls -lSrh' # sort by size
#alias lc='ls -lcrh' # sort by change time
#alias lf="ls -l | egrep -v '^d'" # files only
#alias ldir="ls -l | egrep '^d'" # directories only
alias v="vim"
alias sv='sudo vim'
alias x='exit'
alias ka="killall"
alias sdn="sudo shutdown -h -r now"
#chmod
alias mx='chmod a+x'
alias 000='chmod -R 000'
alias 644='chmod -R 644'
alias 666='chmod -R 666'
alias 755='chmod -R 755'
alias 777='chmod -R 777'
# List disk space
alias df='df -h'
alias free='free -m'
alias diskspace="du -S | sort -n -r |more"
alias folders='du -h --max-depth=1'
alias folderssort='find . -maxdepth 1 -type d -print0 | xargs -0 du -sk | sort -rn'
alias tree='tree -CAhF --dirsfirst'
alias treed='tree -CAFd'
alias mountedinfo='df -hT'
# Listmost used cmds
alias freq='cut -f1 -d" " ~/.bash_history | sort | uniq -c | sort -nr | head -n 30'

#time-saver(though no error checking/perms)
function mcd() {
    \mkdir -p "\$1"
    \cd "\$1"
}

# Search running processes
alias p="ps auwx | grep "
# fkill - kill processes - list only the ones you can kill. Modified the earlier script.
fkill() {
    local pid
    if [ "$UID" != "0" ]; then
        pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}')
    else
        pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
    fi

    if [ "x$pid" != "x" ]
    then
        echo $pid | xargs kill -${1:-9}
    fi
}

# Search files in the current folder
alias f="find . | grep "
alias userlist="cut -d: -f1 /etc/passwd"
alias ebrc='v ~/.bashrc'
alias dt='date "+%Y-%m-%d %A %T %Z +%V"'
# Merge Xresources
alias merge='xrdb -merge ~/.Xresources'

# git
alias ga='git add -u'
alias gaa='git add .'
alias branch='git branch'
alias gb='git checkout -b'
alias clone='git clone'
alias gl='git log --oneline'
alias gc='git commit -m'
alias fetch='git fetch'
alias pull='git pull origin'
alias push='git push origin'
alias gd='git diff'
alias gs='git status'
alias tag='git tag'
alias ntag='git tag -a'
# bare git repo alias for dotfiles
alias config="/usr/bin/git --git-dir=$HOME/dotfiles --work-tree=$HOME"
# fcop, checkout git branch/tag, w/preview commits btw tag/branch/HEAD
fcop() {
  local tags branches target
  branches=$(
    git --no-pager branch --all \
      --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mbranch%09%1B[m%(refname:short)%(end)%(end)" \
    | sed '/^$/d') || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}') || return
  target=$(
    (echo "$branches"; echo "$tags") |
    fzf --no-hscroll --no-multi -n 2 \
        --ansi --preview="git --no-pager log -150 --pretty=format:%s '..{2}'") || return
  git checkout $(awk '{print $2}' <<<"$target" )
}
# fcoc - checkout git commit
fcoc() {
  local commits commit
  commits=$(git log --pretty=oneline --abbrev-commit --reverse) &&
  commit=$(echo "$commits" | fzf --tac +s +m -e) &&
  git checkout $(echo "$commit" | sed "s/ .*//")
}

# list journalctl error msgs
alias jctl="journalctl -p 3 -xb"
# verify iso signature&receive dev key
alias gpg-check="gpg2 --keyserver-options auto-key-retrieve --verify"
alias gpg-retrieve="gpg2 --keyserver-options auto-key-retrieve --receive-keys"

#alias YT="youtube-viewer" \
# Play audio files in current dir by type
alias playmp3='ffplay *.mp3'
alias playmp4='ffplay *.mp4'
# youtube-dl  yt-dlp
#alias yta-aac="yt-dlp --extract-audio --audio-format aac "
alias record="ffmpeg -f x11grab -s 1920x1080 -r 30 -i :0.0 -qscale 0 -vcodec huffyuv"
alias w2p="libreoffice --convert-to pdf *.docx"
# SHA1
alias sha1='openssl sha1'
alias clickpaste='sleep 3; xdotool type "$(xclip -o -selection clipboard)"'
# List all logs in /var/log
alias logs="sudo find /var/log -type f -exec file {} ; | grep 'text' | cut -d' ' -f1 | sed -e's/:$//g' | grep -v '[0-9]$' | xargs tail -f"
#for long running cmds ie. sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
# Alias's for SSH
# alias SERVERNAME='ssh YOURWEBSITE.com -l USERNAME -p PORTNUMBERHERE'
# Alias's to change the directory
alias web='cd /var/www/html'
# Alias's to mount ISO files
# mount -o loop /home/NAMEOFISO.iso /home/ISOMOUNTDIR/
# umount /home/NAMEOFISO.iso
# (Both commands done as root only.)
#Calendar
alias jan='cal -m 01'
alias feb='cal -m 02'
alias mar='cal -m 03'
alias apr='cal -m 04'
alias may='cal -m 05'
alias jun='cal -m 06'
alias jul='cal -m 07'
alias aug='cal -m 08'
alias sep='cal -m 09'
alias oct='cal -m 10'
alias nov='cal -m 11'
alias dec='cal -m 12'

# Count all files (recursively) in the current folder
alias countfiles="for t in files links directories; do echo \`find . -type \${t:0:1} | wc -l\` \$t; done 2> /dev/null"

alias rebootsafe='sudo shutdown -r now'



#D.FUNCTIONS
##Archive (*.tar.gz | zip) from given dir
function maketar() {
    tar cvzf "${1%%/}.tar.gz" "${1%%/}/";
}
function makezip() {
    zip -r "${1%%/}.zip" "${1%%/}/";
}
##cat content of arch files???
##Auto-EXTRACT based on types  Syntax:  ex <file>
ex () {
        for archive in "$@"; do
                if [ -f "$archive" ] ; then
                        case $archive in
                                *.tar.bz2)   tar xvjf $archive    ;;
                                *.tbz2)      tar xvjf $archive    ;;
                                *.tar.gz)    tar xvzf $archive    ;;
                                *.tgz)       tar xvzf $archive    ;;
                                *.bz2)       bunzip2 $archive     ;;
                                *.rar)       rar x $archive       ;;
                                *.gz)        gunzip $archive      ;;
                                *.tar)       tar xvf $archive     ;;
                                *.zip)       unzip $archive       ;;
                                *.Z)         uncompress $archive  ;;
                                *.7z)        7z x $archive        ;;
                                *.rar)       unrar x $1   ;;
                                *.gz)        gunzip $1    ;;
                                *.tar)       tar xf $1    ;;
                                *.deb)       ar x $1      ;;
                                *.tar.zst)   unzstd $1    ;;
                                *  )         tar czf $1   ;;
                                *  )         tar cf $1   ;;
                                *  )         tar cjf $1   ;;
                                *)           echo "Unrecogized archive '$archive'" ;;
                        esac
                else
                        echo "'$archive' is not a valid file!"
                fi
        done
}
##Empty trash
function emptytrash() {
    rm -rf ~/.local/share/Trash/expunged/*
    rm -rf ~/.local/share/Trash/files/*
    rm -rf ~/.local/share/Trash/info/*
    echo "Trash has been emptied."
}
##TerminalReminder poping out dialog when timer ends
reminder() {
    echo "How many minutes from now do you want the reminder?"
    read _TIME
    echo "What should the reminder message say?"
    read _MSG
    echo "Reminder set!"
    sleep ${_TIME}m && zenity --info --text "${_MSG}" >/dev/null 2>&1
}
# Searches for text in all files in the current folder
ftext ()
{
	# -i case-insensitive
	# -I ignore binary files
	# -H causes filename to be printed
	# -r recursive search
	# -n causes line number to be printed
	# optional: -F treat search term as a literal, not a regular expression
	# optional: -l only print filenames and not the matching lines ex. grep -irl "$1" *
	grep -iIHrn --color=always "$1" . | less -r
}

##Copy file w/progress bar
cpp()
{
        set -e
        strace -q -ewrite cp -- "${1}" "${2}" 2>&1 \
        | awk '{
        count += $NF
        if (count % 10 == 0) {
                percent = count / total_size * 100
                printf "%3d%% [", percent
                for (i=0;i<=percent;i++)
                        printf "="
                        printf ">"
                        for (i=percent;i<100;i++)
                                printf " "
                                printf "]\r"
                        }
                }
        END { print "" }' total_size="$(stat -c '%s' "${1}")" count=0
}
##Copy&to the dir
cpg ()
{
        if [ -d "$2" ];then
                cp "$1" "$2" && cd "$2"
        else
                cp "$1" "$2"
        fi
}
##Move&to the dir
mvg ()
{
        if [ -d "$2" ];then
                mv "$1" "$2" && cd "$2"
        else
                mv "$1" "$2"
        fi
}
### Create&to the dir
mkdirg ()
{
        mkdir -p "$1"
        cd "$1"
}


### Up specified #dirs  (i.e. up 4)
up ()
{
        local d=""
        limit=$1
        for ((i=1 ; i <= limit ; i++))
                do
                        d=$d/..
                done
        d=$(echo $d | sed 's/^\///')
        if [ -z "$d" ]; then
                d=..
        fi
        cd $d
}
#Change dirs&list contents
function lc() {
    if ! [[ -z "$1" ]]; then
        cd $1
    fi
    ls -A --color=auto
}

function reload(){
    reset
    source ${HOME}/.bashrc
}
# Backup&Sync2git dotfiles
# Auto-install .bashrc
install_bashrc ()
{
        local dtype
        dtype=$(distribution)

        if [ $dtype == "arch" ]; then
                sudo pacman install multitail tree joe
        elif [ $dtype == "debian" ]; then
                sudo apt-get install multitail tree joe
        else
                echo "Unknown distribution"
        fi
}
# Show the current distribution
distribution ()
{
	local dtype
	# Assume unknown
	dtype="unknown"

	# First test against Fedora / RHEL / CentOS / generic Redhat derivative
	if [ -r /etc/rc.d/init.d/functions ]; then
		source /etc/rc.d/init.d/functions
		[ zz`type -t passed 2>/dev/null` == "zzfunction" ] && dtype="redhat"

	# Then test against SUSE (must be after Redhat,
	# I've seen rc.status on Ubuntu I think? TODO: Recheck that)
	elif [ -r /etc/rc.status ]; then
		source /etc/rc.status
		[ zz`type -t rc_reset 2>/dev/null` == "zzfunction" ] && dtype="suse"

	# Then test against Debian, Ubuntu and friends
	elif [ -r /lib/lsb/init-functions ]; then
		source /lib/lsb/init-functions
		[ zz`type -t log_begin_msg 2>/dev/null` == "zzfunction" ] && dtype="debian"

	# Then test against Gentoo
	elif [ -r /etc/init.d/functions.sh ]; then
		source /etc/init.d/functions.sh
		[ zz`type -t ebegin 2>/dev/null` == "zzfunction" ] && dtype="gentoo"

	# For Mandriva we currently just test if /etc/mandriva-release exists
	# and isn't empty (TODO: Find a better way :)
	elif [ -s /etc/mandriva-release ]; then
		dtype="mandriva"

	# For Slackware we currently just test if /etc/slackware-version exists
	elif [ -s /etc/slackware-version ]; then
		dtype="slackware"

	fi
	echo $dtype
}

# Show the current version of the operating system
ver ()
{
	local dtype
	dtype=$(distribution)

	if [ $dtype == "redhat" ]; then
		if [ -s /etc/redhat-release ]; then
			cat /etc/redhat-release && uname -a
		else
			cat /etc/issue && uname -a
		fi
	elif [ $dtype == "suse" ]; then
		cat /etc/SuSE-release
	elif [ $dtype == "debian" ]; then
		lsb_release -a
		# sudo cat /etc/issue && sudo cat /etc/issue.net && sudo cat /etc/lsb_release && sudo cat /etc/os-release # Linux Mint option 2
	elif [ $dtype == "gentoo" ]; then
		cat /etc/gentoo-release
	elif [ $dtype == "mandriva" ]; then
		cat /etc/mandriva-release
	elif [ $dtype == "slackware" ]; then
		cat /etc/slackware-version
	else
		if [ -s /etc/issue ]; then
			cat /etc/issue
		else
			echo "Error: Unknown distribution"
			exit 1
		fi
	fi
}

# Show current network info
netinfo ()
{
        echo "--------------- Network Information ---------------"
        /sbin/ifconfig | awk /'inet addr/ {print $2}'
        echo ""
        /sbin/ifconfig | awk /'Bcast/ {print $3}'
        echo ""
        /sbin/ifconfig | awk /'inet addr/ {print $4}'

        /sbin/ifconfig | awk /'HWaddr/ {print $4,$5}'
        echo "---------------------------------------------------"
}
###Detailed IPs/hostname
ipif() {
    if grep -P "(([1-9]\d{0,2})\.){3}(?2)" <<< "$1"; then
	 curl ipinfo.io/"$1"
    else
	ipawk=($(host "$1" | awk '/address/ { print $NF }'))
	curl ipinfo.io/${ipawk[1]}
    fi
    echo
}
#Cal
calc() {
    echo "scale=3;$@" | bc -l
}

#Auto- ls after each cd
cd ()
{
       if [ -n "$1" ]; then
               builtin cd "$@" && ls -ahl --color=auto
       else
               builtin cd ~ && ls -ahl --color=auto
       fi
}

#trap to intercept a non-zero return code of the last program run
EC() {
	echo -e '\e[1;33m'code $?'\e[m\n'
}
trap EC ERR

#Compile& execute C source on the fly, exec without args; After program terminates, remove the compiled file.
csource() {
	[[ $1 ]]    || { echo "Missing operand" >&2; return 1; }
	[[ -r $1 ]] || { printf "File %s does not exist or is not readable\n" "$1" >&2; return 1; }
	local output_path=${TMPDIR:-/tmp}/${1##*/};
	gcc "$1" -o "$output_path" && "$output_path";
	rm "$output_path";
	return 0;
}

#Sift through history for previous groups of cmds
function hg() {
    history | grep "$1";
}

#new project w/Git
function git_init() {
    if [ -z "$1" ]; then
        printf "%s\n" "Please provide a directory name.";
    else
        mkdir "$1";
        builtin cd "$1";
        pwd;
        git init;
        touch readme.md .gitignore LICENSE;
        echo "# $(basename $PWD)" >> readme.md
    fi
}

#need https://openweathermap.org/api
function weather_report() {
    local response=$(curl --silent 'https://api.openweathermap.org/data/2.5/weather?id=5128581&units=imperial&appid=<YOUR_API_KEY>')
    local status=$(echo $response | jq -r '.cod')
	# Check for the 200 response indicating a successful API query.
    case $status in

        200) printf "Location: %s %s\n" "$(echo $response | jq '.name') $(echo $response | jq '.sys.country')"
             printf "Forecast: %s\n" "$(echo $response | jq '.weather[].description')"
             printf "Temperature: %.1f°F\n" "$(echo $response | jq '.main.temp')"
             printf "Temp Min: %.1f°F\n" "$(echo $response | jq '.main.temp_min')"
             printf "Temp Max: %.1f°F\n" "$(echo $response | jq '.main.temp_max')"
            ;;
        401) echo "401 error"
            ;;
        *) echo "error"
            ;;

    esac
}

# View Apache logs
apachelog ()
{
	if [ -f /etc/httpd/conf/httpd.conf ]; then
		cd /var/log/httpd && ls -xAh && multitail --no-repeat -c -s 2 /var/log/httpd/*_log
	else
		cd /var/log/apache2 && ls -xAh && multitail --no-repeat -c -s 2 /var/log/apache2/*.log
	fi
}

# Edit the Apache configuration
apacheconfig ()
{
	if [ -f /etc/httpd/conf/httpd.conf ]; then
		sedit /etc/httpd/conf/httpd.conf
	elif [ -f /etc/apache2/apache2.conf ]; then
		sedit /etc/apache2/apache2.conf
	else
		echo "Error: Apache config file could not be found."
		echo "Searching for possible locations:"
		sudo updatedb && locate httpd.conf && locate apache2.conf
	fi
}

# Edit the PHP configuration file
phpconfig ()
{
	if [ -f /etc/php.ini ]; then
		sedit /etc/php.ini
	elif [ -f /etc/php/php.ini ]; then
		sedit /etc/php/php.ini
	elif [ -f /etc/php5/php.ini ]; then
		sedit /etc/php5/php.ini
	elif [ -f /usr/bin/php5/bin/php.ini ]; then
		sedit /usr/bin/php5/bin/php.ini
	elif [ -f /etc/php5/apache2/php.ini ]; then
		sedit /etc/php5/apache2/php.ini
	else
		echo "Error: php.ini file could not be found."
		echo "Searching for possible locations:"
		sudo updatedb && locate php.ini
	fi
}

# Edit the MySQL configuration file
mysqlconfig ()
{
	if [ -f /etc/my.cnf ]; then
		sedit /etc/my.cnf
	elif [ -f /etc/mysql/my.cnf ]; then
		sedit /etc/mysql/my.cnf
	elif [ -f /usr/local/etc/my.cnf ]; then
		sedit /usr/local/etc/my.cnf
	elif [ -f /usr/bin/mysql/my.cnf ]; then
		sedit /usr/bin/mysql/my.cnf
	elif [ -f ~/my.cnf ]; then
		sedit ~/my.cnf
	elif [ -f ~/.my.cnf ]; then
		sedit ~/.my.cnf
	else
		echo "Error: my.cnf file could not be found."
		echo "Searching for possible locations:"
		sudo updatedb && locate my.cnf
	fi
}

# For some reason, rot13 pops up everywhere
rot13 () {
	if [ $# -eq 0 ]; then
		tr '[a-m][n-z][A-M][N-Z]' '[n-z][a-m][N-Z][A-M]'
	else
		echo $* | tr '[a-m][n-z][A-M][N-Z]' '[n-z][a-m][N-Z][A-M]'
	fi
}

# Trim leading and trailing spaces (for scripts)
trim()
{
	local var=$*
	var="${var#"${var%%[![:space:]]*}"}"  # remove leading whitespace characters
	var="${var%"${var##*[![:space:]]}"}"  # remove trailing whitespace characters
	echo -n "$var"
}


#fZF FUNCS
#Git

# ftags - search ctags w/preview, only works if tags-file generated w/ --excmd=number
ftags() {
  local line
  [ -e tags ] &&
  line=$(
    awk 'BEGIN { FS="\t" } !/^!/ {print toupper($4)"\t"$1"\t"$2"\t"$3}' tags |
    fzf \
      --nth=1,2 \
      --with-nth=2 \
      --preview-window="50%" \
      --preview="bat {3} --color=always | tail -n +\$(echo {4} | tr -d \";\\\"\")"
  ) && ${EDITOR:-vim} $(cut -f3 <<< "$line") -c "set nocst" \
                                      -c "silent tag $(cut -f2 <<< "$line")"
}








###auto-Launch apps in terminal
neofetch
